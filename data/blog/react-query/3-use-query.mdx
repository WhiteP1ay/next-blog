---
title: 玩转 useQuery —— react-query 【3】深入了解 useQuery
tags: ['react-query', '技术']
draft: false
summary: 深入了解 useQuery
---

<img
  src="https://phzdoc.oss-cn-beijing.aliyuncs.com/uPic/baiwang.png"
  alt="百望山山门"
  width="80%"
/>

> 百望山山门，在蓝天白云的映衬下显得格外庄严。

这一篇我们详细聊聊`useQuery`，以及它的一些高级用法。

## 条件性请求

所谓条件性请求，就是指 query 只在某个场景下或某种条件达成的前提下进行。

比如：

```tsx
//!!! 错误示范
if (keyword) {
  useQuery({
    queryKey: ['search', keyword],
    queryFn,
  })
}
```

但很明显，这违反了 `hook` 的设计规范。

可以通过传入 `enabled` 来解决条件性请求。即：仅当 `enabled` 为 `true` 时，query 才会被触发。

```tsx
useQuery({
  queryKey: ['search', keyword],
  queryFn,
  enabled: !!keyword,
})
```

## 依赖性请求

依赖性请求是指当前请求依赖于其他请求的结果。

比如：基于书的id请求一本书的详情和作者详情，而作者详情又依赖于作者id，作者id存储在书的详情里。

依赖性请求可以在 `queryFn` 里通过多个 `await` 处理，但这并不利于逻辑的抽象，或者说耦合性过高。

```tsx
//!!! 耦合度过高
useQuery({
  queryKey: ['book', 'comments', bookId],
  queryFn: async () => {
    const book = await fetchBookDetail(bookId)
    const author = await fetchAuthorDetail(book.data.authorId)
    return {
      book,
      author,
    }
  },
})
```

想象一下，假设其他地方也需要基于作者id获取作者详情怎么办？再复制粘贴一份`await fetchAuthorDetail`吗？

这显然不利于维护。

但也不是一无是处，这种处理方式可以让两个请求共享错误处理、loading 状态等等。如果你明确不需要拆分，明确逻辑必然耦合，那这样确实会更加方便。

但我更推荐拆分开，基于 `enabled` 控制请求触发时机。这样更灵活，耦合度更低，是更优雅的逻辑抽象。

```tsx
const useBookDetail = (bookId: string) => {
  return useQuery({
    queryKey: ['book', bookId],
    queryFn: () => fetchBookDetail(bookId),
    enabled: !!bookId,
  })
}
```

```tsx
const useBookAuthor = (authorId: string) => {
  return useQuery({
    queryKey: ['author', authorId],
    queryFn: () => fetchAuthorDetail(authorId),
    enabled: !!authorId,
  })
}
```

```tsx
const useBookDetailAndAuthor = (bookId: string) => {
  const book = useBookDetail(bookId)
  const author = useBookAuthor(book.data?.authorId)

  return {
    book,
    author,
  }
}
```

## 轮询

轮询通常用于那些需要实时性反馈的场景，比如查询用户是否完成支付。

`useQuery` 的 `refetchInterval` 参数可以定义轮询时间，单位毫秒。

```ts
useQuery({
  queryKey: ['list', { sort }],
  queryFn,
  refetchInterval: 5000, // 5 seconds 轮询
})
```

`refetchInterval` 也可以是一个函数。

想象这样一个场景：前端通过轮询来得知用户是否完成支付，用户一旦完成支付轮询就该停止。

```ts
{
   ...,
   refetchInterval: (query)=>{
     if(query.state.data?.finished){
       return false
     }
     return 3000
   }
}
```

## 并发请求

当一些业务场景需要前端并发若干请求时，我们可以在 `queryFn` 里基于 `Promise.all` 来并发请求。

假设有一个作者详情页，在展示书籍详情的同时还需要展示作者的详情。

```ts
const queryFn = async (bookId: string) => {
  const [book, author] = await Promise.all([fetchBookDetail(bookId), fetchAuthorDetail(bookId)])
  return {
    book,
    author,
  }
}

const useBookDetailAndAuthor = (bookId: string) => {
  return useQuery({
    queryKey: ['author', bookId],
    queryFn,
  })
}
```

这很好，但会让两个请求耦合在一起。

假设已经有不需要获取作者的`useBookDetail`了，这里又写了一遍`fetchBookDetail(bookId)`

明显是违反了`DRY`原则。

也可以调用 `useQuery` 多次，但缺点是不能动态控制请求并发的数量。

```ts
const selectedBookIds = [1, 2, 3]
for (let i = 0; i < selectedBookIds.length; i++) {
  // !!! 错误示范 这肯定是不行的
  useFetchBookDetail(selectedBookIds[i])
}
```

`useQueries` 可以很好的解决动态控制数量的问题。

```ts
// 基于ids并发请求，可以动态控制请求数量
const ids = [1, 2, 3]

const combinedQueries = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['book', id],
    queryFn: () => fetchBookDetail(id),
  })),
  combine: (results) => {
    return {
      data: results.map((result) => result.data),
      pending: results.some((result) => result.isPending),
      totalPrice: results.reduce((acc, result) => acc + result.data.price, 0),
    }
  },
})
```

`useQueries` 的 `queries` 参数是一个数组，数组里的每一项都是一个 `useQuery` 的配置对象。

基于 `combine` 可以实现更复杂的聚合逻辑，比如图书详情和评论可能在很多页面都要用到，那就可以基于 `combine` 来聚合。

```ts
const useBookDetailAndComments = (selectedBookId: string) => {
  const { bookComments, bookDetail } = useQueries({
    queries: [
      {
        queryKey: ['book', selectedBookId],
        queryFn: () => fetchBookDetail(selectedBookId!),
        enabled: !!selectedBookId,
      },
      {
        queryKey: ['bookComments', selectedBookId],
        queryFn: () => fetchBookComments(selectedBookId!),
        enabled: !!selectedBookId,
      },
    ],
    combine: (data) => {
      const [bookDetail, bookComments] = data

      if (!bookDetail.data || !bookComments.data) return false

      // 计算好评率是否超过预期
      // 比如：新书（发布不到一个月）好评率超80%，或者老书好评率超90%才算优秀
      const goodRateThreshold = isNewBook(bookDetail.data.publishDate) ? 0.8 : 0.9
      // 看看多少个好评
      const goodComments = bookComments.data.filter((comment) => comment.rating >= 4)
      // 计算好评率
      const goodRate = goodComments.length / bookComments.data.length

      return {
        bookDetail,
        bookComments,
        isGoodComments: goodRate > goodRateThreshold,
      }
    },
  })

  return {
    bookComments,
    bookDetail,
  }
}
```
